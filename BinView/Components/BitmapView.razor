@using BinPlayground.Types
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D

<div class="bitmap-view">
	@if (Bitmap != null)
	{
		<BECanvas Width="@_bitmapWidth" Height="@BitmapHeight" @ref="CanvasReference"></BECanvas>
	}
</div>

@code {
	private Canvas2DContext? _context;

	protected BECanvasComponent? CanvasReference;

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		_context = await CanvasReference.CreateCanvas2DAsync();

		await Update();
	}

	private const int BIT_WIDTH = 32;

	private const int BIT_SIZE = 5;

	private readonly int _bitmapWidth = BIT_WIDTH * BIT_SIZE;

	private long BitmapHeightNum
	{
		get
		{
			long bm_length = (long)(Bitmap?.Length ?? 0);
			long div = bm_length / BIT_WIDTH;
			long mod = bm_length % BIT_WIDTH;

			if (mod > 0)
			{
				div += 1;
			}

			return div;
		}
	}

	private long BitmapHeight => BitmapHeightNum * BIT_SIZE;

	[Parameter]
	public Bytes? Bytes { get; set; }

	public async Task Update()
	{
		if (Bitmap == null || _context == null || CanvasReference == null)
			return;

		var totalLength = Bitmap.Length;

		var heightNum = (ulong)BitmapHeightNum;

		await _context.BeginBatchAsync();

		await _context.ClearRectAsync(0, 0, CanvasReference.Width, CanvasReference.Height);

		for (ulong h = 0; h < heightNum; h++)
		{
			for (ulong w = 0; w < BIT_WIDTH; w++)
			{
				var index = h * BIT_WIDTH + w;
				if (index >= totalLength)
				{
					break;
				}

				var color = Bitmap.GetColor(index);
				var colorString = $"rgb({color[0]} {color[1]} {color[2]})";

				var x = w * BIT_SIZE;
				var y = h * BIT_SIZE;

				await _context.SetFillStyleAsync(colorString);
				await _context.FillRectAsync(x, y, BIT_SIZE, BIT_SIZE);
			}
		}

		await _context.EndBatchAsync();
	}

	private IBytesBitmap? Bitmap => Bytes?.bitmap;
}
