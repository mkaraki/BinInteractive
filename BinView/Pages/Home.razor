@page "/"
@using BinPlayground.Types
@using BinView.Components

<PageTitle>Binary Viewer</PageTitle>

<div class="loading-screen @(_loading ? "" : "hide")">
	<div>
		<div class="spinner-border text-primary" role="status">
			<span class="visually-hidden">Loading...</span>
		</div>
		<p>@(_loadingState)</p>
	</div>
</div>
<div class="@((!_isFileLoaded) ? "" : "hide") landing">
	<div class="container">
		<h1>Online Binary Viewer</h1>
		<div class="mb-3">
			<label for="file-selector" class="form-label">File to inspect</label>
			<div class="input-group">
				<InputFile id="file-selector" class="form-control" OnChange="FileOnChange"></InputFile>
				<button class="btn btn-outline-primary" type="button" @onclick="OpenFile">Open file</button>
			</div>
		</div>
		<hr />
		<div>
			<ul class="nav justify-content-center">
				<li class="nav-item">
					<a href="https://github.com/mkaraki/BinInteractive">Source code</a>
				</li>
			</ul>
		</div>
	</div>
</div>
@if (_isFileLoaded)
{
	<div class="container">
		<div class="row mb-3 mt-3">
			<div class="col">
				File size: @(_fileSize)
				<button @onclick="CloseFile" class="btn btn-danger btn-sm" type="button">Close file</button>
			</div>
		</div>
	</div>
	<div class="container-fluid">
		<div class="row">
			<div class="col">
				<div class="d-flex justify-content-center">
					<div class="hex-and-ascii-view">
						<Virtualize Context="binLine" ItemsProvider="LoadBinLine" OverscanCount="25">
							<ItemContent>
								<code class="address-view-line">
									@((binLine.offset).ToString("X8"))
								</code>

								<code class="hex-view-line">
									@for (var i = 0; i < 16; i++)
									{
										if (i < binLine.length)
										{
											var addr = (long)binLine.offset + i;
											var v = binLine._bytes[i];
											<span style="background-color: @(
											                               v == 0 ? "black" :
											                               v < 0x40 ? "gray" :
											                               v < 0x80 ? "blue" :
											                               v < 0xc0 ? "yellow" :
											                               v < 0xff ? "red" :
											                               /* line[j] == 0xff */ "white"
											                               ) !important;
											         color: @(
											                v == 0 ? "gray" :
											                v < 0x40 ? "white" :
											                v < 0x80 ? "white" :
											                v < 0xc0 ? "black" :
											                v < 0xff ? "white" :
											                /* line[j] == 0xff */ "black"
											                ) !important;"
											      @onclick="async (e) => { await Select(addr, e.ShiftKey); }"
											      class="@((_selectedObject.Contains(addr)) ? "blink" : "")">
												@v.ToString("X2")
											</span>
										}
										else
										{
											<span>&nbsp;&nbsp;</span>
										}
									}
								</code>

								<code class="ascii-view-line">
									@for (var j = 0; j < 16; j++)
									{
										if (j < binLine.length)
										{
											var c = binLine._bytes[j];
											if (c is >= 32 and <= 126)
											{
												@((char)c)
											}
											else
											{
												<span>.</span>
											}
										}
										else
										{
											<span>&nbsp;</span>
										}
									}
								</code>
								<br />
							</ItemContent>
							<Placeholder>
								<code class="address-view-line">
									LOADING&nbsp;
								</code>
								<code class="hex-view-line">
									@for (var i = 0; i < 16; i++)
									{
										<span style="background-color: dimgray; color: white;" >??</span>
									}
								</code>
								<code class="ascii-view-line">
									@foreach (var c in "LOADING LOADING ")
									{
										<span>@c</span>
									}
								</code>
							</Placeholder>
						</Virtualize>
					</div>
					<div class="utilities">
						<BytesUtilities Bytes="_selectedBytes" />
						<LazyBytesUtilities Bytes="_lazySelectedBytes" />
					</div>
				</div>
			</div>
		</div>
	</div>
}

@code {
	private async ValueTask<ItemsProviderResult<Bytes>> LoadBinLine(ItemsProviderRequest request)
	{
		var startByte = request.StartIndex * 16;
		var length = request.Count * 16;

		var totalSize = (int)Math.Ceiling((float)_fileSize / 16.0);

		Console.WriteLine("LoadBinLine->Read(0x{0:X}, 0x{1:X})", startByte, length);
		
		var yanked = await ReadRange(startByte, length);
		if (yanked == null)
		{
			return new ItemsProviderResult<Bytes>([], totalSize);
		}

		var data = new List<Bytes> { };
		for (int i = 0; i < yanked._bytes.Length; i += 16)
		{
			var offset = (int)yanked.offset + i;
			var range = yanked.skip(i /* Skip internal amount */).take(16);
			data.Add(new Bytes(range._bytes, (ulong)offset));
		}

		return new ItemsProviderResult<Bytes>(data, totalSize);
	}

	private BitmapView _bitmapViewComponent = new();

	private const long UNSEEN_READ_AMOUNT = 0x10000;

	private const long LAZY_READ_AMOUNT = 16; /* MAX 64-bit item. */

	private IBrowserFile? _selectedFile = null;

	private bool _loading = false;

	private string _loadingState = "";

	private ulong _fileSize = 0;

	private Bytes? _selectedBytes = null;

	private Bytes? _lazySelectedBytes = null;

	private bool _isFileLoaded = false;

	private List<long> _selectedObject = [];
	private async Task Select(long address, bool isRange)
	{
		if (!isRange)
		{
			_selectedObject = [address];
		}
		else if (_selectedObject.Count == 0)
		{
			await Select(address, false);
		}
		else
		{
			var selectedMin = _selectedObject.Min();
			var selectedMax = _selectedObject.Max();

			if (address < selectedMin)
			{
				_selectedObject = [];
				for (var i = address; i <= selectedMax; i++)
					_selectedObject.Add(i);

			}
			else if (address > selectedMax)
			{
				_selectedObject = [];
				for (var i = selectedMin; i <= address; i++)
					_selectedObject.Add(i);
			}
		}
		
		// Apply selection
		_selectedBytes = await ReadRange(_selectedObject.Min(), _selectedObject.Count());
		_lazySelectedBytes = await ReadRange(_selectedObject.Min(), LAZY_READ_AMOUNT);
	}
	
	private void FileOnChange(InputFileChangeEventArgs e)
	{
		try
		{
			_selectedFile = e.File;
		}
		catch
		{
			_selectedFile = null;
		}
	}

	private async Task OpenFile()
	{
		if (_selectedFile == null) return;
		_loading = true;
		// Test Read
		await ReadRange(0, 1);
		_loading = false;
		_isFileLoaded = true;
	}

	private void CloseFile()
	{
		_selectedFile = null;
		_isFileLoaded = false;
	}

	private async Task<Bytes?> ReadRange(long pos, long length)
	{
		if (_selectedFile == null)
			return null;

		await using (var rs = _selectedFile.OpenReadStream(maxAllowedSize: long.MaxValue))
		{
			_fileSize = (ulong)rs.Length;
			
			if (rs.Length == 0)
			{
				return null;
			}
			if (pos >= rs.Length)
			{
				pos = rs.Length - 1;
			}

			_loadingState = "seeking file stream to position";
			await Seek(rs, pos);

			var readAmount = Math.Min(length, Math.Max(0, rs.Length - pos));
			var buffer = new byte[readAmount];
			_loadingState = "Reading file stream to buffer";
			Console.WriteLine("ReadFromFile, Current: 0x{0:X}, Length: 0x{1:X}", rs.Position, buffer.Length);
			await rs.ReadExactlyAsync(buffer, 0, buffer.Length);

			return new Bytes(buffer, (ulong)pos);
		}
	}

	private async Task Seek(Stream stream, long pos)
	{
		// stream.Position not supported on Blazor WebAssembly
		//stream.Position = 0;
		
		ulong seekNum = 0;

		while (stream.Position != pos)
		{
			var seekAmount = Math.Min(UNSEEN_READ_AMOUNT, pos - stream.Position);

			_loadingState = $"Seeking {seekAmount} bytes... {++seekNum}";

			var buffer = new byte[seekAmount];
			
			Console.WriteLine($"Seeking 0x{seekAmount:X} bytes... {seekNum}");
			
			// Do seek virtually
			await stream.ReadExactlyAsync(buffer, 0, buffer.Length);
		}
	}

}
